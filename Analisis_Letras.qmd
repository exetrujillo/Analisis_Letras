---
title: "Análisis de Letras"
author: "Exequiel Trujillo Escobar"
date: "`r Sys.Date()`"
description: "Exploración y análisis de letras de canciones utilizando la API de LRC Lib."
format: 
  html:
    css: styles.css
    highlight-style: monokai
editor: visual
---

# Introducción

Este proyecto utiliza R para realizar análisis de letras de canciones. Se usará la database de \[LRCLIB\](<https://lrclib.net/db-dumps>)

#### Tareas por hacer (ToDo):

-   **Validación de entradas:**

    -   La conexión a la base de datos podría estar en una función separada.

    -   Mejora en la visualización:

        -   Para inspeccionar el `dataframe` resultante, usar librerías como `DT` o `kableExtra`

    -   Análisis:

        -   Frecuencias de palabras

        -   ¿Sentimientos? ¿Emociones?

        -   Gráficos ggplot

    -   Explorar la existencia de paquetes para estudios lingüísticos y literarios con reconocimiento de pátrones de lenguaje por gramática en español.

## Instalación de librerías

Primero, cargamos las librerías necesarias:

```{r}

library(pacman)

p_load(httr,
       jsonlite,
       dplyr,
       rvest,
       DBI,
       RSQLite,
       stringi
       )

rm(list = ls()) # Descomentar si necesitamos limpiar entorno
```

# Exploración de la base de datos

Aquí importamos la base de datos, sus tablas y el tipo de información que pueden contener

## Importar base de datos

```{r}

# Conectar a la base de datos
db_file <- "db.sqlite3"
conn <- dbConnect(RSQLite::SQLite(), dbname = db_file)

# Listar tablas
# tables <- dbListTables(conn)
# print(tables)
```

El resultado son las siguientes tablas:

|  |  |  |  |  |  |
|------------|------------|------------|------------|------------|------------|
| "\_litestream_lock" | "\_litestream_seq" | "flags" | "lyrics" | "missing_tracks" | "sqlite_sequence" |
| "tracks" | "tracks_fts" | "tracks_fts_config" | "tracks_fts_data" | "tracks_fts_docsize" | "tracks_fts_idx" |

## Exploramos las tablas

```{r}

# Leer los primeros registros de una tabla
# data <- dbGetQuery(conn, "SELECT * FROM lyrics LIMIT 10")
# print(data)

# Consultar la estructura de la tabla
columns <- dbGetQuery(conn, "PRAGMA table_info(lyrics)")
print(columns)
```

## Estructura de las tablas de interés

Nos interesa particularmente la tabla tracks y la tabla lyrics

### Tracks

| Columna | Tipo | Descripción | Ejemplo |
|------------------|------------------|-------------------|------------------|
| `id` | INT | Clave primaria de la tabla. Usada para identificar de manera única cada canción o pista. | 3 |
| `name` | TEXT | Nombre de la canción o pista. Es sensible a mayúsculas y minúsculas. | Wildest Dreams |
| `name_lower` | TEXT | Versión en minúsculas del nombre de la pista (`name`). | wildest dreams |
| `artist_name` | TEXT | Nombre del artista que interpreta la canción. Sensible a mayúsculas y minúsculas. | ZAYN feat. Sia |
| `artist_name_lower` | TEXT | Versión en minúsculas del nombre del artista (`artist_name`). | zayn feat sia |
| `album_name` | TEXT | Nombre del álbum en el que se encuentra la canción. | Dusk Till Dawn (Radio Edit) |
| `album_name_lower` | TEXT | Versión en minúsculas del nombre del álbum (`album_name`). | dusk till dawn radio edit |
| `duration` | FLOAT | Duración de la canción en segundos. | 239 |
| `last_lyrics_id` | INT | Referencia a otra tabla (como `lyrics`) que almacena las letras de las canciones. Algunas no coinciden con `id` necesariamente. | 3 |
| `created_at` | DATE | Representa la fecha y la hora en que se creó el registro. | 2022-11-14 11:46:45.978+00:00 |
| `updated_at` | DATE | Indica la fecha (y hora) en que se actualizó por última vez el registro. | 2022-11-14 11:46:45.978+00:00 |

### Lyrics

| Columna | Tipo | Descripción | Ejemplo |
|------------------|------------------|-------------------|------------------|
| `id` | INT | Clave primaria de la tabla, única para cada registro de letras. | 3 |
| `plain_lyrics` | TEXT | Letras de la canción en formato simple (sin sincronización con la música). | Not tryna be indie\\nNot tryna be cool\\nJust tryna be in this\\nTell me, are you too?\\n\\nCan \[...\] |
| `synced_lyrics` | TEXT | Letras sincronizadas, con marcas de tiempo para seguir la canción mientras se reproduce. | \[00:09.66\] Not tryna be indie\\n\[00:12.30\] Not tryna be cool\\n\[00:14.99\] Just tryna be in \[...\] |
| `track_id` | INT | Clave foránea que referencia la columna `id` en la tabla `tracks`. Esto vincula las letras con las canciones. | 3 |
| `has_plain_lyrics` | BOOLEAN | Indica si hay letras simples disponibles (\[`TRUE` = 1\] o \[`FALSE` = 0\]). | 1 |
| `has_synced_lyrics` | BOOLEAN | Indica si hay letras sincronizadas disponibles (\[`TRUE` = 1\] o \[`FALSE` = 0\]). | 1 |
| `instrumental` | BOOLEAN | Indica si la pista es instrumental y, por lo tanto, no tiene letras. (\[`TRUE` = 1\] o \[`FALSE` = 0\]). | 0 |
| `source` | TEXT | Fuente de las letras (La mayoría está en NA). | NA |
| `created_at` | DATE | Fecha y hora de creación del registro. | 2022-11-14 11:46:45.978+00:00 |
| `updated_at` | DATE | Fecha y hora de la última actualización del registro. | 2022-11-14 11:46:45.978+00:00 |

# Definición de funciones

Ya teniendo claridad de la estructura de las tablas que nos interesan, comenzaremos a crear las funciones que nos permitan crear nuestros propios data frames y analizar las canciones que nos interesen.

## Variables iniciales de ejemplo

```{r}

artista_ej <- "Niños del Cerro"
```

## Normalizar nombre de artista

Normalizar los nombres de los artistas es estandarizar su "formato" para que sean uniformes, independientemente de cómo estén registrados en la base de datos o ingresados por el usuario. Esto es útil para evitar problemas como registros duplicados o consultas fallidas debido a diferencias en mayúsculas, espacios, acentos, o caracteres especiales, como la ñ en "Niños del Cerro".

```{r}

# Normalizar Texto
nrmlztxt <- function(texto) {
  texto <- tolower(texto)                          # Minúsculas
  texto <- trimws(texto)                           # Espacios
  texto <- gsub("\\s+", " ", texto)                # Espacios
  texto <- stri_trans_general(texto, "Latin-ASCII") # Acentos
  texto <- gsub("[^a-z0-9 ]", "", texto)           # Puntuación
  return(texto)
}

# Lo probamos
artista_ej_nrm <- nrmlztxt(artista_ej)
print(artista_ej_nrm)
```

Se ve que el resultado es "ninos del cerro", sin espacios, ni ñ, ni mayúsculas.

## Obtener canciones de un artista con las letras

```{r}
buscarPorArtista <- function(nombre_artista, conexion) {
  # Paso 0: Normalizar y proteger el nombre del artista
  nombre_artista <- nrmlztxt(nombre_artista)            # Normalizar texto
 nombre_artista <- dbQuoteString(conexion, nombre_artista) # Proteger para consultas SQL
  
  # Paso 1: Consulta SQL con nombre del artista protegido
  query <- paste0("
    SELECT 
      t.id AS track_id, t.name,t.name_lower, t.artist_name, t.artist_name_lower, t.album_name, t.album_name_lower, t.duration, t.updated_at,l.id AS lyrics_id, l.plain_lyrics, l.synced_lyrics, l.has_plain_lyrics, l.has_synced_lyrics, l.instrumental
    FROM tracks t
    LEFT JOIN lyrics l ON t.last_lyrics_id = l.id
    WHERE t.artist_name_lower = ", nombre_artista
  )
  
  # Ejecutar la consulta
  data <- dbGetQuery(conexion, query)
  
  # Verificar si se encontraron canciones
  if (nrow(data) == 0) {
    cat("No se encontraron canciones para este artista.\n")
    return(NULL)
  }
  
  # Paso 2: Resolver duplicados
  data <- data %>%
    group_by(track_id) %>%
    filter(
      has_synced_lyrics == 1 | # Priorizar letras sincronizadas
      updated_at == max(updated_at, na.rm = TRUE) # Priorizar registros más recientes
    ) %>%
    ungroup()
  
  # Retornar el dataframe final
  return(data)
}


# Ejemplo de uso de la función con nombre normalizado
df_artista_ej <- buscarPorArtista(artista_ej_nrm, conn)

# Mostrar las primeras filas del dataframe final
head(df_artista_ej)
```

Arroja 47 filas con 15 variables: **track_id** (\<int\>), **name** (\<chr\>), **name_lower** (\<chr\>), **artist_name** (\<chr\>), **artist_name_lower** (\<chr\>), **album_name** (\<chr\>), **album_name_lower** (\<chr\>), **duration** (\<dbl\>), **updated_at** (\<chr\>), **lyrics_id** (\<int\>), **plain_lyrics** (\<chr\>), **synced_lyrics** (\<chr\>), **has_plain_lyrics** (\<int\>), **has_synced_lyrics** (\<int\>) e **instrumental** (\<int\>).
